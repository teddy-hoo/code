# 函数重载的实现

### 符号表

C or C++源文件在编译时生成的可重定位目标文件，有个ELF header，结构如下：

```
ELF 头
-------
.text        已编译程序的机器代码
-------
.rodata      只读数据，比如printf中的常量字符串和switch语句的跳转表
-------
.bss         未初始化的全局C变量
-------
.symtab      符号表
-------
.rel.text    .text节中的位置的列表
-------
.rel.data    被模块引用或者定义的任何全局变量的重定位信息
-------
.strtab      字符串表，其内容包括.symtab 中的符号表中的字符串          
```

#### 符号表中包含三种不同的符号

* 由本模块定义被其他模块引用的全局符号
* 由其他模块定义并被本模块引用的全局符号
* 本模块定义而且只被被模块引用的本地符号   如C语言中的static变量

如下面的代码：

```
void swap();

int buf[2] = {1, 2};

int main()
{
	swap();
	return 0;
}
```
它的符号表如下：

| num | value | size | type | bind | ot | name |
| :---: | -- | -- |---|---|
|8|0|8|OBJECT|GLOBAL|0|3|buf|


### C++ 中函数重载后的符号表

C++中能使用函数重载，是因为编译器将每个唯一的方法和参数列表组合编码成一个对连接器来说唯一的名字，这种编码过程叫做毁坏（mangling）。一个被毁坏的类名字是由名字中字符的整数数量，后面跟上原始名字组成的。比如，类Foo被编码成3Foo，方法被编码成原始方法名，后面跟上\_ \_，加上被毁坏的类名，再加上每个参数的单个字母编码，比如Foo::bar(int, long) 被编码为 bar\_\ _3Fooil.