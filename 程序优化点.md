# 程序优化点

#### 原始程序

```
void combine1(vec_ptr v, int *dest)
{
        long int  i;
        *dest = 1;
        for (i = 0; i < vec_length(v); i++) {
                int val;
                get_vec_element(v, i, &val);
                *dest = *dest * val;
        }
}
```

#### 优化点一：消除循环本身的低效率

```
void combine2(vec_ptr v, int *dest)
{
        long int  i;
        *dest = 1;
        long int length = vec_length(v);
        for (i = 0; i < length; i++) {
                int val;
                get_vec_element(v, i, &val);
                *dest = *dest * val;
        }
}
```

#### 优化点二：减少函数调用

```
void combine3(vec_ptr v, int *dest)
{
        long int i;
        *dest = 1;
        long int length = vec_length(v);
        int * start = get_vec_start(v);
        for (i = 0; i < length; i ++) {
                *dest = *dest * start[i];
        }
}
```

#### 优化点三：消除不必要的存储器引用

```
void combine4(vec_ptr v, int *dest)
{
        long int i;
        int acc = 1;
        long int length = vec_length(v);
        int * start = get_vec_start(v);
        for (i = 0; i < length; i ++) {
                acc = acc * start[i];
        }
        *dest = acc;
}
```

#### 优化点四：循环展开
这里的步长为2，实验结果是2、3几乎没有区别，说明2在这一点上已经做到了最优的优化。

_优化原因：_

1. 减少了计数器的计算次数
2. 减少了关键路径的指令操作数量（个人认为这个因机器而异，比如我的测试机上，几乎没有变化）

```
void combine5(vec_ptr v, int * dest)
{
        long int i;
        long int length = vec_length(v);
        long int limit = length - 1;
        int * start = get_vec_start(v);
        int acc = 1;

        for ( i = 0; i < limit; i += 2) {
                acc = acc * start[i] * start[i + 1];
        }

        for (; i < length; i ++) {
                acc *= start[i];
        }

        *dest = acc;
}
```

#### 优化点五：高级循环展开

这下牛逼了，这里使用了两个临时变量存储中间结果，使得两个乘法运算在微指令级别可以做到完全并行执行，从而得到了较大的提高。

```
void combine6(vec_ptr v, int * dest)
{
        long int i;
        long int length = vec_length(v);        long int limit = length - 2;
        int * start = get_vec_start(v);
        int acc0 = 1;
        int acc1 = 1;

        for (i = 0; i < limit; i += 2) {
                acc0 *= start[i];
                acc1 *= start[i + 1];
        }

        for (; i < length; i ++) {
                acc0 *= start[i];
        }

        *dest = acc0 * acc1;
}
```

## 注解：程序全貌

```
//vec.h
typedef struct {
        long int len;
        int *data;
} vec_rec, *vec_ptr;
```

```
//vec.c
#include <stdlib.h>
#include "vec.h"

vec_ptr new_vec(long int len)
{
        vec_ptr result = (vec_ptr) malloc(sizeof(vec_rec));
        if (!result) return NULL;
        result->len = len;
        if (len > 0) {
                int * data = (int *)calloc(len, sizeof(int));
                if (!data) {
                        free((void *) result);
                        return NULL;
                }
                result->data = data;
        } else {
                result->data = NULL;
        }
        return result;
}

int get_vec_element(vec_ptr v, long int index, int *dest)
{
        if (index < 0 || index >= v->len)
                return 0;
        *dest = v->data[index];
        return 1;
}

int * get_vec_start(vec_ptr v)
{
        return v->data;
}

long int vec_length(vec_ptr v)
{
        return v->len;
}
```

```
//main.c
#include<stdio.h>
#include "vec.h"

void combine1(vec_ptr v, int *dest)
{
        long int  i;
        *dest = 1;
        for (i = 0; i < vec_length(v); i++) {
                int val;
                get_vec_element(v, i, &val);
                *dest = *dest * val;
        }
}

void combine2(vec_ptr v, int *dest)
{
        long int  i;
        *dest = 1;
        long int length = vec_length(v);
        for (i = 0; i < length; i++) {
                int val;
                get_vec_element(v, i, &val);
                *dest = *dest * val;
        }
}

void combine3(vec_ptr v, int *dest)
{
        long int i;
        *dest = 1;
        long int length = vec_length(v);
        int * start = get_vec_start(v);
        for (i = 0; i < length; i ++) {
                *dest = *dest * start[i];
        }
}

void combine4(vec_ptr v, int *dest)
{
        long int i;
        int acc = 1;
        long int length = vec_length(v);
        int * start = get_vec_start(v);
        for (i = 0; i < length; i ++) {
                acc = acc * start[i];
        }
        *dest = acc;
}

void combine5(vec_ptr v, int * dest)
{
        long int i;
        long int length = vec_length(v);
        long int limit = length - 2;
        int * start = get_vec_start(v);
        int acc = 1;

        for ( i = 0; i < limit; i += 3) {
                acc = acc * start[i] * start[i + 1] * start[i + 2];
        }

        for (; i < length; i ++) {
                acc *= start[i];
        }

        *dest = acc;
}

void combine6(vec_ptr v, int * dest)
{
        long int i;
        long int length = vec_length(v);
        long int limit = length - 2;
        int * start = get_vec_start(v);
        int acc0 = 1;
        int acc1 = 1;

        for (i = 0; i < limit; i += 2) {
                acc0 *= start[i];
                acc1 *= start[i + 1];
        }

        for (; i < length; i ++) {
                acc0 *= start[i];
        }

        *dest = acc0 * acc1;
}

int main()
{
        vec_ptr vec = (vec_ptr)new_vec(100);
        int i;
        for (i = 0; i < 100; i++) {
                vec->data[i] = 1;
        }
        int dest;
        for (i = 0; i < 1000000; i++) {
                combine6(vec, &dest);
        }
}
```